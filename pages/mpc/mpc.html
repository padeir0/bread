<html>
<head>
  <link rel="stylesheet" href="../../normalize.css">
  <link rel="stylesheet" href="../../style.css">
  <link rel="icon" href="../../images/bread.png">
  <title>mpc</title>
</head>
<body>
<div class="header">
  <a href="../../index.html">bread</a>
  <a href="https://github.com/padeir0">github</a>
</div>
<div class="container">
  <div class="title">
    <h1>The Millipascal Compiler</h1>
  </div>
  <div class="abstract">
    <p>
      This document is an exposition of the Millipascal compiler (<code>mpc</code>),
      it explains on a high level how each component of the compiler works,
      and serves as resource for other people who are trying to solve
      similar problems as i did.
    </p>
    <p>
      An additional resource to this document is the
      <a href="../millipascal-spec/spec.html">millipascal specification</a>.
    </p>
  </div>
  <div class="summary">
    <ol>
      <li><a href="#mp-briefly">A brief description of Millipascal</a></li>
      <li><a href="#mpc-briefly">The overall compiler architecture</a></li>
      <li><a href="#ast">The abstract syntax tree (AST)</a></li>
      <li><a href="#lex-parser">Lexer and parser</a></li>
      <li><a href="#files">Files and modules</a></li>
      <li><a href="#module-graph">The module graph</a></li>
      <li><a href="#scope">The data structure for scopes</a></li>
      <li><a href="#name-resolution">Steps in name resolution</a></li>
      <li><a href="#types">The type system</a></li>
      <li><a href="#type-of-types">The data structures for types</a></li>
      <li><a href="#typechecking">Type inference and type checking</a></li>
      <li><a href="#consteval">Constant evaluation</a></li>
      <li><a href="#abstract-machine">The abstract machine</a></li>
      <li><a href="#hir">The High level Intermediate Representation (HIR)</a></li>
      <li><a href="#ast-hir">From AST to HIR</a></li>
      <li><a href="#hir-errors">Checking proper returns</a></li>
      <li><a href="#hir-validation">HIR validation</a></li>
      <li><a href="#mir">The Middle-level Intermediate Representation (MIR)</a></li>
      <li><a href="#hir-mir">From HIR to MIR (register allocation)</a></li>
      <li><a href="#mir-fasm">From MIR to FASM</a></li>
      <li><a href="#end">The End</a></li>
    </ol>
  </div>
  <section>
    <h2 id="mp-briefly">A brief description of Millipascal</h2>
    <p>
      Millipascal is a simple imperative language.
      It looks like Pascal, hence the name. Here's a hello-world program:
    </p>
<pre><code>
from io import print

data hello "Hello, World!\n"

proc main
begin
  print[hello, sizeof[hello]];
end
</code></pre>
    <p>
      This program hardly shows anything about the language.
      But what we can see is that:
    </p>
    <ul>
      <li>There is some sort of module system</li>
      <li>For some reason I didn't place the string literal inline with the print call</li>
      <li>There is an entry point called <code>main</code></li>
      <li>Functions appear to be called with square brackets</li>
      <li>It looks like Pascal.</li>
    </ul>
    <p>
      Millipascal is very minimalistic, the reason string literals are not directly
      present in expressions is that they are only treated as blobs,
      just like you would treat strings in assembly. The identifier
      <code>hello</code> evaluates to a pointer (<code>ptr</code>),
      completely untyped.
    </p>
    <p>
      Besides pointers, we have the basic signed integers and
      unsigned integers from 8 bits to 64 bits, and a boolean.
      The boolean is not strictly necessary, but it helps when
      we're trying to validate our compiler transformations (more
      on that later).
    </p>
    <p>
      Now, why would I choose square brackets over parenthesis
      for function calls? That is: why <code>f[]</code> instead of
      <code>f()</code>? There are three main reasons:
    </p>
    <ul>
      <li>Parenthesis already have a job inside expressions: to disambiguate and group terms</li>
      <li>It takes less finger acrobatics to type <code>[</code> than <code>(</code> </li>
      <li>I find it prettier.</li>
    </ul>
    <p>
      After you get used to this call syntax, it grows on you.
      Initially it was a decision based purely to make the grammar
      more robust, then i started seeing other advantages.
    </p>
    <p>
      Now, if you're familiar with how <code>print</code> is implemented
      in other languages, you know how weird our software stack
      can get. In millipascal it is not much better, here's
      one of the only assembly procedures I ever got working in the language:
    </p>

<pre><code>export print

const begin
    SYS_WRITE = 1;
    STDOUT = 1;
end

proc print&lt;stack&gt;[p:ptr, size:i32] i64
asm
begin
    push rbp;
    mov rbp, rsp;

    mov r0, {SYS_WRITE};
    mov r2d, [rbp, size]@dword;
    mov r6, [rbp, p]@qword;
    mov r7, {STDOUT};
    syscall;

    mov [rbp, _ret0]@qword, r0;
    mov rsp, rbp;
    pop rbp;
    ret;
end</code></pre>

    <p>
      This directly implements the write syscall on linux for amd64.
      Lot's more questions may be raised about this piece of code.
      The <code>export print</code> is
      how we make names public to other modules.
      When you see <code>&lt;stack&gt;</code>, this is specifying
      the ABI the procedure will use. Only one ABI was ever implemented.
    </p>
    <p>
      If by now you haven't realised yet, this project was never finished.
      It is functional, and I've even wrote a arbitrary precision
      number library for the language, but some features never got fully
      developed. The support for multiple ABIs exist, but only one ABI
      was ever implemented. The support for ASM procedures exist, but
      only few procedures got throughly used and tested. This is what
      happens when projects grow out of proportion.
    </p>
    <p>
      The following procedure converts a buffer to uppercase.
      This one is much more interesting, it shows that the language
      has support for first class procedures, and that global symbols
      can be declared out of order.
    </p>
<pre><code>from io import print

data buff "am i uppercase yet?\n"

proc main
begin
  byte_map[buff, sizeof[buff], upper_case];
  print[buff, sizeof[buff]];
end

proc byte_map[b:ptr, bsize:i32, op:proc[i8][i8]]
var i:i32
begin
  set i = 0;
  while i &lt; bsize begin
    set (b+i)@i8 = op[(b+i)@i8];
    set i += 1;
  end
end

proc upper_case[a:i8] i8
begin
  if a &gt;= 'a' and a &lt;= 'z' begin
    return a - 32ss;
  end
  return a;
end
</code></pre>
  <p>
    Here, <code>(b+1)@i8</code> is a pointer offset followed
    by a dereference. It reads
    "take b, add 1 and read an <code>i8</code> from that address".
    There are other ways to do this, in fact, the language has
    support for indexing, but it requires introducing the
    semantics behind <code>struct</code> (it's different from C,
    much to your dismay).
  </p>
  <p>
    To be more precise, structs in millipascal are only syntax sugar
    for pointers, they are not values per se, only compile-time
    metadata for pointers.
    Here's some code that uses structs to benefit from the use of
    the indexing syntax:
  </p>
<pre><code>from ioutil import put_int, put_char

struct I32A begin
    num:i32;
end

# ~ in Millipascal is the unary minus (arithmetical negation)
data my_ints:I32A {
    5, ~10, 2, 50, ~9, 65, 0
}
const my_ints_length = sizeof[my_ints]/sizeof[I32A];

proc main
begin
    print_ints[my_ints, my_ints_length];
    insertion_sort[my_ints, my_ints_length];
    print_ints[my_ints, my_ints_length];
end

proc insertion_sort[array:I32A, length:i32]
var i, j:i32
begin
    set i = 1;
    while i &lt length begin
        set j = i;
        while j &gt; 0 and
              array[j-1]-&gt;num &gt; array[j]-&gt;num begin
            set array[j]-&gt;num &lt&gt; array[j-1]-&gt;num;
            set j -= 1;
        end
        set i += 1;
    end
end

proc print_ints[array:I32A, length:i32]
var i:i32
begin
    set i = 0;
    while i &lt length begin
        put_int[array[i]-&gt;num:i64];
        put_char[' '];
        set i += 1;
    end
    put_char['\n'];
end</code></pre>
  <p>
    It may seem confusing, but <code>array[i]</code> is only
    syntax sugar for <code>array+(i * sizeof[I32A])</code>.
    The <code>-&gt;</code> operator performs a dereference, just like in
    C. It is sugar for <code>(pointer+offset)@type</code>, in this particular case,
    the offset is zero, so the expression <code>array[i]-&gt;num</code>
    is sugar for:
  </p>
  <pre><code>(array+(i * sizeof[I32A]))@i32</code></pre>
  <p>
    Structs are a bit more powerful than that, we're able to specify
    the offsets of fields, and even have negative offsets. This may
    seem silly, but i implemented that already thinking of a use-case:
    storing metadata about an object.
  </p>
<pre><code># object header
struct Obj [sizeof[i64]] begin
    Size:i64 {~sizeof[i64]};
end</code></pre>
  <p>
    This <code>Obj</code> struct is used inside the
    <a href="https://github.com/padeir0/millipascal/blob/master/test_suite/stdlib/flalloc.mp">flalloc.mp</a>
    allocator
    to retrieve the size of objects that come from user code:
  </p>
  <pre><code>set size = (p:Obj)->Size;</code></pre>
  <p>
    So far this is only a taste of the weird quirks of the language,
    a few more will crop up on the way, but now you know what rabbit
    hole you're getting into. If it is not clear how some mechanism
    of the language works, a <a href="../millipascal-spec/spec.html">specification</a> is available. If even
    then something seems wrong, please feel free to
    <a href="https://github.com/padeir0/bread/issues">raise an issue</a>.
  </p>
  </section>
  <section>
    <h2 id="mpc-briefly">The overall compiler architecture</h2>
  </section>
  <section>
    <h2 id="ast">The abstract syntax tree (AST)</h2>
  </section>
  <section>
    <h2 id="lex-parser">Lexer and parser</h2>
  </section>
  <section>
    <h2 id="files">Files and modules</h2>
  </section>
  <section>
    <h2 id="module-graph">The module graph</h2>
  </section>
  <section>
    <h2 id="scope">The data structure for scopes</h2>
  </section>
  <section>
    <h2 id="name-resolution">Steps in name resolution</h2>
  </section>
  <section>
    <h2 id="types">The type system</h2>
  </section>
  <section>
    <h2 id="type-of-types">The data structures for types</h2>
  </section>
  <section>
    <h2 id="typechecking">Type inference and type checking</h2>
  </section>
  <section>
    <h2 id="consteval">Constant evaluation</h2>
  </section>
  <section>
    <h2 id="abstract-machine">The abstract machine</h2>
  </section>
  <section>
    <h2 id="hir">The High level Intermediate Representation (HIR)</h2>
  </section>
  <section>
    <h2 id="ast-hir">From AST to HIR</h2>
  </section>
  <section>
    <h2 id="hir-errors">Checking proper returns</h2>
  </section>
  <section>
    <h2 id="hir-validation">HIR validation</h2>
  </section>
  <section>
    <h2 id="mir">The Middle-level Intermediate Representation (MIR)</h2>
  </section>
  <section>
    <h2 id="hir-mir">From HIR to MIR (register allocation)</h2>
  </section>
  <section>
    <h2 id="mir-fasm">From MIR to FASM</h2>
  </section>
  <section>
    <h2 id="end">The End</h2>
  </section>
</div>
</body>
</html>
